#pragma once

#include "fiskta.h"
#include <stdio.h>

static inline void print_usage(void)
{
    printf("(fi)nd (sk)ip (ta)ke v%s\n", FISKTA_VERSION);
    printf("\n");
    printf("USAGE:\n");
    printf("  fiskta [options] <operations>\n");
    printf("  (use --input <path> to select input; defaults to stdin)\n");
    printf("\n");
    printf("  fiskta --input text.txt skip 5l take 8c\n");
    printf("\n");
    printf("  fiskta -i logs.txt find \"ERROR:\" take to line-end\n");
    printf("\n");
    printf("  fiskta -i config.txt find \"[database]\" skip 1b take until \"[\"\n");
    printf("\n");
    printf("  fiskta -i emails.txt find:re \"[A-Za-z0-9._%%+-]+@[A-Za-z0-9.-]+\" take to match-end\n");
    printf("\n");
    printf("  fiskta -i image.bin find:bin \"89 50 4E 47 0D 0A 1A 0A\" print \"PNG\" OR fail \"Not a PNG file\"\n");
    printf("\n");
    printf("OPERATIONS:\n");
    printf("  take <n><unit>              Extract n units from current position\n");
    printf("  take to <location>          Order-normalized: emits [min(cursor,L), max(cursor,L));\n");
    printf("                              cursor moves to the high end\n");
    printf("  take until <string> [at match-start|match-end|line-start|line-end]\n");
    printf("                              Search forward, extract to specified position\n");
    printf("                              Default: match-start (excludes pattern)\n");
    printf("                              match-end includes; line-* relative to match\n");
    printf("  take until:re <regex> [at match-start|match-end|line-start|line-end]\n");
    printf("                              Same as take until but with regex pattern support\n");
    printf("  take until:bin <hex-string> [at match-start|match-end|line-start|line-end]\n");
    printf("                              Same as take until but with binary pattern (hex format)\n");
    printf("  skip <n><unit>              Move cursor n units (no output); negative moves backward\n");
    printf("  skip to <location>          Move cursor to location (no output)\n");
    printf("  find [to <location>] <string>\n");
    printf("                              Search towards location (default: EOF)\n");
    printf("                              for <string>, move cursor to closest match\n");
    printf("  find:re [to <location>] <regex>  Regex enabled find\n");
    printf("  find:bin [to <location>] <hex-string>\n");
    printf("                              Find binary pattern (hex: DEADBEEF or DE AD BE EF)\n");
    printf("                              Case-insensitive, whitespace ignored\n");
    printf("  label <name>                Mark current position with label\n");
    printf("  view <L1> <L2>              Limit all ops to [min(L1,L2), max(L1,L2))\n");
    printf("  clear view                  Clear view; return to full file\n");
    printf("  print <string>              Emit literal bytes (alias: echo)\n");
    printf("                              Supports escape sequences: \\n \\t \\r \\0 \\\\ \\xHH \\c (cursor offset)\n");
    printf("                              Participates in clause atomicity\n");
    printf("  fail <message>              Write message to stderr and fail clause\n");
    printf("                              Message written immediately (not staged)\n");
    printf("                              Useful with OR for error messages\n");
    printf("\n");
    printf("UNITS:\n");
    printf("  b                           Bytes\n");
    printf("  l                           Lines\n");
    printf("  c                           UTF-8 code points\n");
    printf("\n");
    printf("LABELS:\n");
    printf("  NAME                        Uppercase, <16 chars, [A-Z0-9_-], starts with letter\n");
    printf("\n");
    printf("LOCATIONS:\n");
    printf("  cursor                      Current cursor position\n");
    printf("  BOF                         Beginning of file\n");
    printf("  EOF                         End of file\n");
    printf("  match-start                 Start of last match\n");
    printf("  match-end                   End of last match\n");
    printf("  line-start                  Start of current line\n");
    printf("  line-end                    End of current line\n");
    printf("  <label>                     Named label position\n");
    printf("  Note: line-start/line-end are relative to the cursor here; in \"at\" (for\n");
    printf("  \"take until\") they're relative to the last match.\n");
    printf("\n");
    printf("OFFSETS:\n");
    printf("  <location> +<n><unit>       n units after location\n");
    printf("  <location> -<n><unit>       n units before location\n");
    printf("                              (attached offsets like BOF+100b are allowed)\n");
    printf("\n");
    printf("REGEX SYNTAX:\n");
    printf("  Character Classes: \\d (digits), \\D (non-digits), \\w (word), \\W (non-word),\n");
    printf("                     \\s (space), \\S (non-space), [a-z], [^0-9]\n");
    printf("  Quantifiers: * (0+), + (1+), ? (0-1), {n} (exactly n), {n,m} (n to m)\n");
    printf("  Grouping: ( ... ) (group subpatterns), (a|b)+ (quantified groups)\n");
    printf("  Anchors: ^ (line start), $ (line end)\n");
    printf("  Alternation: | (OR)\n");
    printf("  Escape: \\n, \\t, \\r, \\f, \\v, \\0\n");
    printf("  Special: . (any char except newline)\n");
    printf("\n");
    printf("CLAUSES AND LOGICAL OPERATORS:\n");
    printf("  Operations are grouped into clauses connected by logical operators:\n");
    printf("    THEN    Sequential execution (always runs next clause)\n");
    printf("    OR      First success wins (short-circuits on success)\n");
    printf("\n");
    printf("  Within a clause: all ops must succeed or the clause fails atomically.\n");
    printf("  On Failure: clause rolls back (no output or state changes).\n");
    printf("  On Success: emits staged output, commits labels, updates cursor and last-match.\n");
    printf("\n");
    printf("EXIT CODES:\n");
    printf("  0               Success (includes normal --until-idle stop)\n");
    printf("  1               Program failure (no clause succeeded in only/final iteration)\n");
    printf("  2               Execution timeout (--for elapsed)\n");
    printf("  10              I/O error (open/read/write failure)\n");
    printf("  11              Resource limit (program too large, out of memory)\n");
    printf("  12              Parse error (invalid syntax, unknown operation)\n");
    printf("  13              Regex error (invalid regex pattern)\n");
    printf("\n");
    printf("OPTIONS:\n");
    printf("  -i, --input <path>          Read input from path (default: stdin)\n");
    printf("      --ops <string|file>     Provide operations as a string or file path\n");
    printf("      --                      Treat subsequent arguments as operations\n");
    printf("      --for <time>            Halt execution after set duration\n");
    printf("  -k, --ignore-failures       Suppress exit code 1 when all clauses fail (keep going)\n");
    printf("                              Especially useful with iterative modes to continue looping\n");
    printf("  -h, --help                  Show this help message\n");
    printf("  -v, --version               Show version information\n");
    printf("Iterative modes and options:\n");
    printf("      --continue, -c           Re-run fiskta and resume from last cursor position each iteration\n");
    printf("      --follow, -f             Re-run fiskta but process only new data since last iteration\n");
    printf("      --monitor, -m            Re-run fiskta and re-scan entire file each iteration\n");
    printf("      --every <time>           Interval between iterations (default 0 = tight loop)\n");
    printf("      --until-idle <time>      Stop when input has not grown for specified duration\n");
    printf("\n");
}
